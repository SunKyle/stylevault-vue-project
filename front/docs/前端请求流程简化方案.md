# 前端请求流程简化方案

## 当前架构分析

通过分析当前的代码结构，发现前端请求流程存在以下问题：

1. **层级过多**：当前流程经过7个层级（组件层 -> Store层 -> Adapter层 -> Service层 -> API层 -> API Adapter层 -> HTTP客户端层）
2. **职责重叠**：多个层级都在做类似的错误处理、数据传递
3. **代码冗余**：大量重复的try/catch块和错误处理逻辑
4. **过度抽象**：抽象层级过多导致理解和维护成本增加
5. **依赖复杂**：模块之间的依赖关系复杂，增加了重构难度

## 简化架构设计

### 目标架构

将7层架构简化为3层：

1. **组件层**：Vue组件，负责UI渲染和用户交互
2. **Store层**：Pinia stores，负责状态管理和业务逻辑
3. **API客户端层**：统一的API请求处理层，负责HTTP通信

### 关键设计决策

1. **移除Adapter层**：将其职责合并到Store层
2. **移除Service层和API层**：将它们的核心功能合并到统一的API客户端
3. **保留请求锁和缓存机制**：这些是重要的性能优化
4. **统一错误处理**：在API客户端层集中处理错误
5. **简化数据流转**：减少中间转换步骤

## 具体实现方案

### 1. 创建统一的API客户端

```javascript
// src/services/apiClient.js
import axios from 'axios';
import { showToast } from '../utils/toast';

// 创建axios实例
const apiClient = axios.create({
  baseURL: process.env.VUE_APP_API_BASE_URL || 'http://localhost:3000/api/v1',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// 请求拦截器
apiClient.interceptors.request.use(
  config => {
    // 添加token等认证信息
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  error => {
    return Promise.reject(error);
  }
);

// 响应拦截器 - 统一错误处理
apiClient.interceptors.response.use(
  response => {
    // 统一处理响应数据
    return response.data;
  },
  error => {
    // 统一处理错误
    let errorMessage = '请求失败';
    
    if (error.response) {
      switch (error.response.status) {
        case 401:
          errorMessage = '未授权访问，请登录';
          break;
        case 404:
          errorMessage = '请求的资源不存在';
          break;
        case 500:
          errorMessage = '服务器错误，请稍后再试';
          break;
        default:
          errorMessage = `请求错误: ${error.response.status}`;
      }
    } else {
      errorMessage = '网络错误，请检查您的网络连接';
    }
    
    console.error(errorMessage, error);
    // 可以在这里添加统一的错误提示逻辑
    // showToast(errorMessage, 'error');
    
    return Promise.reject(error);
  }
);

// API端点配置
const API_ENDPOINTS = {
  clothing: {
    getCategories: '/categories',
    getItems: '/clothing',
    getItemById: (id) => `/clothing/${id}`,
    createItem: '/clothing',
    updateItem: (id) => `/clothing/${id}`,
    deleteItem: (id) => `/clothing/${id}`,
    search: '/clothing/search',
    favorite: (id) => `/clothing/${id}/favorite`,
  },
  // 其他API端点配置
};

// 通用CRUD方法
const createApiService = (resource) => {
  return {
    getAll: async (params = {}) => {
      return apiClient.get(API_ENDPOINTS[resource].getItems, { params });
    },
    
    getById: async (id) => {
      return apiClient.get(API_ENDPOINTS[resource].getItemById(id));
    },
    
    create: async (data) => {
      return apiClient.post(API_ENDPOINTS[resource].createItem, data);
    },
    
    update: async (id, data) => {
      return apiClient.put(API_ENDPOINTS[resource].updateItem(id), data);
    },
    
    delete: async (id) => {
      return apiClient.delete(API_ENDPOINTS[resource].deleteItem(id));
    },
    
    // 可以添加其他特定于资源的方法
  };
};

// 导出特定服务
export const clothingApi = createApiService('clothing');

// 添加衣物特定方法
clothingApi.getCategories = async () => {
  return apiClient.get(API_ENDPOINTS.clothing.getCategories);
};

clothingApi.search = async (query) => {
  return apiClient.get(API_ENDPOINTS.clothing.search, { params: query });
};

clothingApi.toggleFavorite = async (id) => {
  return apiClient.post(API_ENDPOINTS.clothing.favorite(id));
};

// 导出其他服务
export default apiClient;
```

### 2. 简化Store层实现

```javascript
// src/stores/modules/clothingStore.js
import { defineStore } from 'pinia';
import { clothingApi } from '../../services/apiClient';
import { showToast } from '../../utils/toast';

// 缓存工具（可以提取到单独的utils文件）
const cache = new Map();
const CACHE_DURATION = 5 * 60 * 1000; // 5分钟缓存

const isCacheValid = (key) => {
  const cached = cache.get(key);
  if (!cached) return false;
  return Date.now() - cached.timestamp < CACHE_DURATION;
};

const getCachedData = (key) => {
  const cached = cache.get(key);
  return cached && isCacheValid(key) ? cached.data : null;
};

const setCachedData = (key, data) => {
  cache.set(key, {
    data,
    timestamp: Date.now(),
  });
};

export const useClothingStore = defineStore('clothing', {
  state: () => ({
    categories: [],
    clothingItems: [],
    selectedCategory: null,
    loading: false,
    error: null,
    pagination: {
      currentPage: 1,
      itemsPerPage: 50,
      totalItems: 0,
    },
    _fetchClothingItemsPromise: null, // 请求锁
  }),

  getters: {
    // 保留现有的getters
    selectedItems: (state) => {
      const items = Array.isArray(state.clothingItems) ? state.clothingItems : [];
      if (state.selectedCategory) {
        return items.filter(item => item && item.category === state.selectedCategory);
      }
      return items;
    },
    // 其他getters...
  },

  actions: {
    setLoading(status) {
      this.loading = status;
    },

    setError(error) {
      this.error = error;
    },

    clearError() {
      this.error = null;
    },

    // 直接调用API客户端，移除中间层
    async fetchCategories(forceRefresh = false) {
      const cacheKey = 'categories';

      // 防止重复请求
      if (this.loading && !forceRefresh) return this.categories;

      // 检查缓存
      if (!forceRefresh && getCachedData(cacheKey)) {
        this.categories = getCachedData(cacheKey);
        return this.categories;
      }

      this.setLoading(true);
      this.clearError();

      try {
        // 直接调用API
        const response = await clothingApi.getCategories();
        
        // 确保获取到的数据是数组格式
        let categoriesData = [];
        if (Array.isArray(response.data)) {
          categoriesData = response.data;
        } else if (Array.isArray(response)) {
          categoriesData = response;
        } else if (response && response.length === undefined) {
          categoriesData = [response];
        }
        
        this.categories = categoriesData.map(category => ({
          id: category.id,
          name: category.name || category.display_name || '未命名类别',
          icon: category.icon || 'shirt',
          enabled: category.enabled !== undefined ? category.enabled : 
                  (category.is_active !== undefined ? category.is_active : true),
          ...category
        }));
        
        setCachedData(cacheKey, this.categories);
        return this.categories;
      } catch (error) {
        this.setError('获取衣物类别失败');
        this.categories = [];
        showToast('获取衣物类别失败', 'error');
        throw error;
      } finally {
        this.setLoading(false);
      }
    },

    async fetchClothingItems(forceRefresh = false) {
      const cacheKey = 'clothingItems';

      // 并发控制
      if (this._fetchClothingItemsPromise && !forceRefresh) {
        return this._fetchClothingItemsPromise;
      }

      // 检查缓存
      if (!forceRefresh && getCachedData(cacheKey)) {
        this.clothingItems = getCachedData(cacheKey);
        this.pagination.totalItems = this.clothingItems.length;
        return this.clothingItems;
      }

      this.setLoading(true);
      this.clearError();

      try {
        // 直接调用API
        this._fetchClothingItemsPromise = clothingApi.getAll();
        const response = await this._fetchClothingItemsPromise;
        
        const items = response.items || response.data?.items || response.data || [];
        this.clothingItems = Array.isArray(items) ? items : [];
        this.pagination.totalItems = response.pagination?.totalItems || this.clothingItems.length;
        setCachedData(cacheKey, this.clothingItems);
        
        return this.clothingItems;
      } catch (error) {
        this.setError('获取衣物列表失败');
        this.clothingItems = [];
        showToast('获取衣物列表失败', 'error');
        throw error;
      } finally {
        this.setLoading(false);
        this._fetchClothingItemsPromise = null;
      }
    },

    // 其他actions也采用类似的简化方式...
  },
});
```

### 3. 组件层调用方式（保持不变）

组件层仍然通过store调用，接口保持一致，这样可以确保兼容性：

```javascript
// 在组件中使用
import { useClothingStore } from '@/stores/modules/clothingStore';

export default {
  setup() {
    const clothingStore = useClothingStore();
    
    const loadData = async () => {
      await clothingStore.fetchClothingItems();
    };
    
    return {
      loadData,
      clothingItems: computed(() => clothingStore.clothingItems)
    };
  }
};
```

## 实施步骤

1. **准备阶段**：
   - 创建`apiClient.js`作为统一的API客户端
   - 测试新的API客户端功能

2. **逐步迁移**：
   - 选择一个Store进行迁移测试（如clothingStore）
   - 修改Store直接使用新的API客户端
   - 移除对应的Adapter和Service层文件
   - 进行功能测试确保正常工作

3. **全面推广**：
   - 按模块逐步迁移所有Store
   - 清理不再使用的Adapter和Service文件
   - 更新相关文档

## 简化带来的好处

1. **减少代码量**：预计减少30-40%的重复代码
2. **提高可维护性**：层级减少，职责更清晰
3. **降低理解成本**：新人更容易理解请求流程
4. **统一错误处理**：错误处理逻辑集中管理
5. **性能提升**：减少中间层数据传递开销
6. **简化调试**：调用链变短，更容易定位问题

## 注意事项

1. **兼容性**：确保Store层的接口保持不变，以避免破坏现有组件
2. **错误处理**：确保所有错误都能被正确捕获和处理
3. **测试**：每个迁移步骤都需要进行充分测试
4. **性能优化**：保留原有的缓存和请求锁等优化机制
5. **回滚计划**：准备好回滚方案，以防出现问题

## 后续优化建议

1. **类型安全**：引入TypeScript类型定义，提高代码健壮性
2. **请求重试**：添加自动重试机制，提高系统稳定性
3. **请求取消**：实现请求取消功能，避免不必要的请求
4. **统一状态管理**：考虑使用更统一的错误和加载状态管理
5. **文档完善**：完善API文档，方便前端开发使用